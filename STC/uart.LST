C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 17:58:59 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE uart.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <STC12C5A60S2.H>
   2          #include "uart.h"
   3          #define S2RI 0x01 //串口2接收中断请求标志位
   4          #define MOTOR P14
   5          uint   j =  0   ;
   6          uchar  GP2Y_DATA[]={0xAA,0x00,0x00,0x00,0x00,0x00,0xFF,0x00};
   7          float v0=0.0;
   8          float PM=0.0;
   9          uchar MOTOR_SPEED=10;
  10          uint GP2Y_K=800;
  11          uchar getflag;
  12          uchar *time="00:00:00";
  13          uchar timeflag=0;
  14          
  15          void Uart_One_Init()           //串口1初始化函数，波特率9600
  16          {
  17   1        TMOD=0x21;//设置定时器1为工作方式2
  18   1        TH1=0xfd; //设置波特率为9600
  19   1        TL1=0xfd;
  20   1        TR1=1;
  21   1        REN=1;
  22   1        SM0=0;
  23   1        SM1=1;
  24   1        EA=1;
  25   1        ES=1;
  26   1      //  AUXR|=0X40;       //T1*12;
  27   1      }
  28          //========================================
  29          void Uart_One_Send(char k)       //串口1发送一个字符
  30          {
  31   1        ES  =  0 ;
  32   1         SBUF=k;
  33   1          while(TI!=1);
  34   1          TI  =  0 ;
  35   1          ES  =  1  ;
  36   1      }
  37          //=========baud 2400=======================
  38          void Uart_Two_Init()       //串口2初始化函数，波特率2400
  39          {
  40   1          AUXR &= 0xF7;   //波特率不倍速
  41   1          S2CON = 0x50;   //8位数据,可变波特率
  42   1          AUXR |= 0x04;   //独立波特率发生器时钟为Fosc,即1T
  43   1          BRT = 0x70;   //设定独立波特率发生器重装值
  44   1          AUXR |= 0x10;   //启动独立波特率发生器
  45   1          IE2=0x01;
  46   1      }
  47          
  48          //=============================================
  49          void UART_One_Printf(uchar *p)
  50          {
  51   1         while(* p!='\0') Uart_One_Send(*p++);
  52   1      }
  53          //===========================================
  54          void Uart_One_Receive() interrupt 4
  55          {
C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 17:58:59 PAGE 2   

  56   1        if(RI==1)
  57   1        {
  58   2          RI = 0   ;
  59   2          if(SBUF=='G'){
  60   3            getflag=0;
  61   3            timeflag=1;
  62   3          }
  63   2          if(timeflag>0&&timeflag<9){
  64   3            time[timeflag-1]=SBUF;
  65   3            timeflag++;
  66   3          }else{
  67   3            timeflag=0;
  68   3          }
  69   2          if(SBUF=='M'){
  70   3            MOTOR=!MOTOR;
  71   3          }
  72   2          if(SBUF=='U'){
  73   3            MOTOR_SPEED-=1;
  74   3          }
  75   2          if(SBUF=='D'){
  76   3            MOTOR_SPEED+=1;
  77   3          }
  78   2        }
  79   1      }
  80          //========================================
  81          void Uart_Two_Receive() interrupt 8
  82          {
  83   1        EA=0;
  84   1        if(S2CON&S2RI)
  85   1        {
  86   2          S2CON&=~S2RI;
  87   2          GP2Y_DATA[j]=S2BUF;
  88   2          if(S2BUF==0xff){
  89   3            j=0;
  90   3            GP2Y_CAL();
  91   3            GP2Y_DATA[7]=0xFF;
  92   3          }else if(S2BUF==0xaa){
  93   3            j=1;
  94   3          }else{
  95   3            j++;
  96   3          }
  97   2        }
  98   1        EA=1;
  99   1      }
 100          //=====================================
 101          void GP2Y_CAL()
 102          {
 103   1        uchar flag=0;
 104   1        uint sum;
 105   1        sum=GP2Y_DATA[1]+GP2Y_DATA[2]+GP2Y_DATA[3]+GP2Y_DATA[4];
 106   1        if(sum==GP2Y_DATA[5]){
 107   2          v0=(GP2Y_DATA[1]*256.0+GP2Y_DATA[2])/1024.0*5.0;
 108   2          PM=v0*GP2Y_K;
 109   2        }else{
 110   2          v0=0.0;
 111   2          PM=999.0;
 112   2        }
 113   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    478    ----
C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 17:58:59 PAGE 3   

   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
