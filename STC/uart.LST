C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 18:46:31 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE uart.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <STC12C5A60S2.H>
   2          #include "uart.h"
   3          #define S2RI 0x01 //串口2接收中断请求标志位
   4          #define MOTOR P14
   5          uint   j =  0   ;
   6          uchar  GP2Y_DATA[]={0xAA,0x00,0x00,0x00,0x00,0x00,0xFF,0x00};
   7          float v0=0.0;
   8          float PM=0.0;
   9          uchar MOTOR_SPEED=10;
  10          uint GP2Y_K=800;
  11          uchar getflag;
  12          uchar time[]={'0','1',':','0','0',':','0','0'};
  13          uchar temp[16],tempflag;
  14          
  15          void Uart_One_Init()           //串口1初始化函数，波特率9600
  16          {
  17   1        TMOD=0x21;//设置定时器1为工作方式2
  18   1        TH1=0xfd; //设置波特率为9600
  19   1        TL1=0xfd;
  20   1        TR1=1;
  21   1        REN=1;
  22   1        SM0=0;
  23   1        SM1=1;
  24   1        EA=1;
  25   1        ES=1;
  26   1      //  AUXR|=0X40;       //T1*12;
  27   1      }
  28          //========================================
  29          void Uart_One_Send(char k)       //串口1发送一个字符
  30          {
  31   1        ES  =  0 ;
  32   1         SBUF=k;
  33   1          while(TI!=1);
  34   1          TI  =  0 ;
  35   1          ES  =  1  ;
  36   1      }
  37          //=========baud 2400=======================
  38          void Uart_Two_Init()       //串口2初始化函数，波特率2400
  39          {
  40   1          AUXR &= 0xF7;   //波特率不倍速
  41   1          S2CON = 0x50;   //8位数据,可变波特率
  42   1          AUXR |= 0x04;   //独立波特率发生器时钟为Fosc,即1T
  43   1          BRT = 0x70;   //设定独立波特率发生器重装值
  44   1          AUXR |= 0x10;   //启动独立波特率发生器
  45   1          IE2=0x01;
  46   1      }
  47          
  48          //=============================================
  49          void UART_One_Printf(uchar *p)
  50          {
  51   1         while(* p!='\0') Uart_One_Send(*p++);
  52   1      }
  53          //===========================================
  54          void Uart_One_Receive() interrupt 4
  55          {
C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 18:46:31 PAGE 2   

  56   1        uint i=0;
  57   1        if(RI==1)
  58   1        {
  59   2          RI = 0;
  60   2          if(SBUF=='G'){
  61   3            getflag=0;
  62   3          }else if(SBUF=='I'){
  63   3            tempflag=0;
  64   3            for(i=0;i<8;i++)
  65   3              time[i]=temp[i];
  66   3          }else if(SBUF=='M'){
  67   3            MOTOR=!MOTOR;
  68   3          }else if(SBUF=='U'){
  69   3            MOTOR_SPEED--;
  70   3            Uart_One_Send(MOTOR_SPEED/10+0x30);
  71   3            Uart_One_Send(MOTOR_SPEED%10+0x30);
  72   3          }else if(SBUF=='D'){
  73   3            MOTOR_SPEED++;
  74   3            Uart_One_Send(MOTOR_SPEED/10+0x30);
  75   3            Uart_One_Send(MOTOR_SPEED%10+0x30);
  76   3          }else{
  77   3            temp[tempflag]=SBUF;
  78   3            tempflag++;
  79   3          }
  80   2        }
  81   1      }
  82          //========================================
  83          void Uart_Two_Receive() interrupt 8
  84          {
  85   1        EA=0;
  86   1        if(S2CON&S2RI)
  87   1        {
  88   2          S2CON&=~S2RI;
  89   2          GP2Y_DATA[j]=S2BUF;
  90   2          if(S2BUF==0xff){
  91   3            j=0;
  92   3            GP2Y_CAL();
  93   3            GP2Y_DATA[7]=0xFF;
  94   3          }else if(S2BUF==0xaa){
  95   3            j=1;
  96   3          }else{
  97   3            j++;
  98   3          }
  99   2        }
 100   1        EA=1;
 101   1      }
 102          //=====================================
 103          void GP2Y_CAL()
 104          {
 105   1        uchar flag=0;
 106   1        uint sum;
 107   1        sum=GP2Y_DATA[1]+GP2Y_DATA[2]+GP2Y_DATA[3]+GP2Y_DATA[4];
 108   1        if(sum==GP2Y_DATA[5]){
 109   2          v0=(GP2Y_DATA[1]*256.0+GP2Y_DATA[2])/1024.0*5.0;
 110   2          PM=v0*GP2Y_K;
 111   2        }else{
 112   2          v0=0.0;
 113   2          PM=999.0;
 114   2        }
 115   1      }


C51 COMPILER V9.52.0.0   UART                                                              05/14/2016 18:46:31 PAGE 3   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    505    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
